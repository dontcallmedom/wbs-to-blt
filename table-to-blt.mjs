/**
* This tool reads a file with a single table element in it and
* generates a BLT file as input to OpenSTV
* https://github.com/Conservatory/openstv
*
* The format of the table is that generated by a WBS rank-order
* control. The code assumes that the title attribute on each
* table cell includes both the rank information and the candidate.
*
* The rank-order control allows voters to leave candidates "Unranked".
*
* Arguments:
* - HTML file with a table with class including "results"; the code picks the first one
*   because this is what WBS forms produce.
* - The number of seats available for election
* - Optional: The title that should appear in the BLT file (not semantically important).
*
* For information about the BLT file format, see:
* https://github.com/Conservatory/openstv/blob/master/openstv/Help.html
*
* Assumptions:
* - Each ballot has a weight of 1.
* - OpenSTV says: You don't need to rank all of the candidates on each
*                 ballot, but you cannot skip rankings and you 
*                 cannot give two or more candidates the same ranking."
*   Therefore, we ignore ballots with gaps and ballots where two or
*   more candidates have the same ranking. However, we report these phenomena.
* - OpenSTV says: "OpenSTV only accepts valid ballots, and an empty
*   ballot is valid." Therefore we preserve empty ballots.
*/

import { readFile } from 'node:fs/promises';
import { JSDOM } from 'jsdom';

async function main(file, nbseats, electionname) {
    const html = await readFile(file, { encoding: 'utf8'});
    let dom = new JSDOM(html);
    generateBLT(dom, nbseats, electionname);
}

function generateBLT (dom, nbseats, electionname) {
  // NOTE: The first column is the name of the voter.
  let table = dom.window.document.querySelector("table")

  // Ignore first column in determining number of candidates.
  const nbcandidates = table.querySelector("tr").querySelectorAll('td,th').length - 1;
  let rows = table.querySelectorAll("tr");

  // candidates is the list of candidate names, taken from the top (zeroth) row of the table.
  const candidates = Array.from(rows[0].querySelectorAll('th')).map(s => s.innerHTML).slice(1) ;
    
  // Create ballots
  const ballots = generateBallots(dom, rows, candidates);
  
  // Start output in BLT format
  // First row is number of candidates and number of seats
  console.log(nbcandidates + " " + nbseats);
  // List of ballots, each with weight "1" and ending with "0"
  console.log(ballots.map(s => "1 " + s.join(" ") + " 0").join("\n"));
  // Zero separator
  console.log("0");
  // Names of candidates, ignoring the first column.
  for (let i = 1; i <= nbcandidates; i++) {
    console.log("\"Candidate " + i + "\"");
  }
  // Election name
  console.log("\"" + electionname + "\"");
}

function generateBallots(dom, rows, candidates) {
    let ballots = [];
    // Handle rows. Ignore top (zeroth) row since that is candidate names.
    for (let i = 1; i < rows.length; i++) {
        // Handle cells in the row.
        let cells = rows[i].querySelectorAll('td');
	let unranked = Array.from(cells).map(getVote);

        // Per OpenSTV, ballot is invalid if there are duplicate rankings.
        if (duplicateRankings(unranked)) {
	   console.error("Ballot ignored (duplicate rankings): " + rows[i].querySelector('th').innerHTML);
	   continue;
	}

        // Sort the candidates so the array of cells goes from top ranked (1) to lowest ranked.
        let rankedcells = [...unranked].sort(sortByRank);

        // Per OpenSTV, ballot is invalid if there are skips in rankings.
        if (!noSkips(rankedcells, cells.length)) {
	   console.error("Ballot ignored (skips in rankings): " + rows[i].querySelector('th').innerHTML);
	   continue;
	}

	let ordered = [];
        for (let j = 0; j < cells.length; j++) {
	  // Unranked candidates are demoted in the list by giving them very high rank (Number.POSITIVE_INFINITY).
	  // Remove these candidates from the generated ballot.
	  if (rankedcells[j].rank != Number.POSITIVE_INFINITY) {
  	     ordered.push(candidates.indexOf(rankedcells[j].candidate) + 1);
	  }
        }

	ballots.push(ordered);
    }
    return(ballots);
 }

function getVote (cell) {
  // WBS form generates "Ranked N" (most of the time). Remove "Ranked"
  const re1 = /.*\s+([0123456789])$/ ;
  const re2 = /\s*Unranked\s*/ ;
  let title = cell.getAttribute('title');
  if (title != null) {
     return { candidate: title.split(':')[0], rank: title.split(':')[1].replace(re1, "$1").replace(re2, Number.POSITIVE_INFINITY) };

  } else {
     return ("");
  }
}

function sortByRank(a, b) {
  return a.rank - b.rank;
}

function duplicateRankings(ballot) {
  const noUnranked = ballot.filter(v => v.rank != Number.POSITIVE_INFINITY);
  const uniqueValues = new Set(noUnranked.map(v => v.rank));
  return (uniqueValues.size < noUnranked.length);
}

function noSkips(ballot, nb) {
  // The ranks have been sorted here (with duplicate ballots thrown out).
  // Detect gaps by creating a string of the rankings and seeing if it's a strict substring
  // of j=1 to nbcandidates, starting at position zero. This allows for unranked candidates.
  const canonical = Array(nb).fill().map((e,i) => i + 1).join('');
  const ballotstring = ballot.map(e => e.rank == Number.POSITIVE_INFINITY ? '' : e.rank).join('');
  return canonical.startsWith(ballotstring);
}

const file = process.argv[2];
const nbseats = process.argv[3];
const electionname = process.argv[4] === undefined ? ("Election " + new Date().toISOString().slice(0, 10)) : process.argv[4];

main(file, nbseats, electionname)
  .catch(err => {
    console.log(`Something went wrong: ${err.message}`);
    throw err;
  });
